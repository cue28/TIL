# greedy Algorithm

- 탐욕 알고리즘은 말 그대로 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법
1. 선택 절차(Selection Procedure): 현재 상태에서의 최적의 해답을 선택한다.
2. 적절성 검사(Feasibility Check): 선택된 해가 문제의 조건을 만족하는지 검사한다.
3. 해답 검사(Solution Check): 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위의 과정을 반복한다.
- 하지만, 항상 최적의 결과를 보장하지는 못한다. 그러나 어느정도 최적에 근사한 값을 빠르게 도출할 수 있는 장점이 있다. 따라서, 근사 알고리즘으로 사용할 수 있다.
- 조건
    - 탐욕적 선택 속성(Greedy Choice Property) : 앞의 선택이 이후의 선택에 영향을 주지 않는다.
    - 최적 부분 구조(Optimal Substructure) : 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다.

# implementation

- 알고리즘을 푼다는 것은, 내가 생각한 문제 해결 과정을 컴퓨팅 사고로 변환하여 코드로 구현한다는 것과 같다.
- 구현 능력이 보는 대표적인 사례 : 완전 탐색(brute force)과 시뮬레이션(simulation)

### 완전 탐색

- 가능한 모든 경우의 수를 전부 확인하여 문제를 푸는 방식
- 단순하고 무식하지만 "답이 무조건 있다"
- brute Force(조건/반복을 사용하여 해결), 재귀, 순열, DFS/BFS

### 시뮬레이션

- 문제에서 요구하는 복잡한 구현 요구 사항을 하나도 빠트리지 않고 코드로 옮겨, 마치 시뮬레이션을 하는 것과 동일한 모습

### (Advanced) Dynamic Programming

- DP; 동적 계획법
- 탐욕 알고리즘과 같이 작은 문제에서부터 출발한다는 점은 같다.
- 그러나 탐욕 알고리즘이 매 순간 최적의 선택을 찾는 방식이라면, Dynamic Programming은 모든 경우의 수를 조합해 최적의 해법을 찾는 방식이다.
- 주어진 문제를 여러 개의 하위 문제로 나누어 풀고, 하위 문제들의 해결 방법을 결합하여 최종 문제를 해결하는 문제 해결 방식
- 조건
    - 큰 문제를 작은 문제로 나눌 수 있고, 이 작은 문제가 중복해서 발견된다. (Overlapping Sub-problems)
    - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 같다. 즉, 작은 문제에서 구한 정답을 큰 문제에서도 사용할 수 있다. (Optimal Substructure)
    

Recursion + Memoization(결과를 저장하는 방법)

Iteration + Tabulation

크롬 개발자 도구에서 함수 실행 시간 측정 방법

```js
var t0 = performance.now();
fib(50); // 여기에서 함수 실행을 시켜주세요
var t1 = performance.now();
console.log("runtime: " + (t1 - t0) + 'ms')
```

### 🔍  look-up table

배열이나 객체를 활용해 사용할 정보를 미리 저장해두는 것

꺼내쓴다!